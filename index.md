# 深度剖析 GO 为何火热
![](images/gopher2222.jpeg)
## 为什么要学习 GO 语言
```
GO 是互联网时代的 C 语言  		by 许式伟 
```
1. 天生支持高并发，goroutine, channel

2. 工程哲学，简约，非学术语言。关键字 25 个，想比 c 语言 32, java 53, c++ 62 ...
```
package import go goto defer return var const type  func map chan interface struct range select for continue break switch case default fallthrough if  else
```

3. 语法简单，[少即是多](https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html)，学习曲线平坦
4. 作者 Robert Griesemer、Rob Pike、Ken Thompson， 大牛云集，质量得以保证
5. 静态，强一致类型语言，开发效率高兼具线上运行稳定安全

## 语言方面的对比
开宗明义，莫要唯语言论，没有最好，只有适合
### 从小处看工程哲学
```
# cat test.c
#include <stdio.h>

int main(){
	int a;
	printf("value: %d, sizeof: %ld\n", a, sizeof(a));
	return 0;
}
# gcc test.c && ./a.out
value: 319529014, sizeof: 4
```
```
# cat test.go
package main

import "fmt"
import "unsafe"

func main(){
	var a int
	fmt.Printf("value: %d, sizeof: %d\n", a, unsafe.Sizeof(a))
}
# go run test.go
value: 0, sizeof: 8
```
分析：大学时代，老师教我们 int 是四字节，有符号最大 21 亿，无符号 42 亿。如果 c 语言中一个变量未初始化，那么值可能是随机的， 因为创建局部变量只是 bp 指针向下移动而己。但，现在都 9012 年了，64 位系统己成主流，不必在按位去使用内存，所以 go 语言默认 64 位的 int 就是 8 字节大小。创建变量时，go 也会直接初始化成零值，防止不必要的问题，从实践中来到实践中去。

```
int binary_search(int * list,int len,int target){
    int low = 0;
    int hight = len-1;
    int middle;
    while(low <= hight){
        middle = (low + hight)/2; // mid = low - (low-hight)/2
        if(list[middle] = target)
        {
            return list[middle];
        }
        else if(list[middle] > target)
        {
            hight = middle -1;
        }
        else if(list[middle] < target)
        {
            low = middle + 1;
        }
    }
    return -1;
}
```
分析：这是 c 语言写的二分查找算法，在很长一段时间里都是不能正确工作，原因就在于 mid 求值可能会溢出

### 垃圾回收，不用关心内存分配与回收
```
package main

import "fmt"

func genSlice() []int{
	arr:=make([]int, 100)
	for i:=0;i<len(arr);i++{
		arr[i]=i+100
	}
	return arr
}

func main(){
	var a int
	fmt.Println(a)
	arr := genSlice()
	fmt.Println(arr[10])
}

$ go build -gcflags='-m' test.go
# command-line-arguments
./test.go:15:13: inlining call to fmt.Println
./test.go:17:13: inlining call to fmt.Println
./test.go:6:11: make([]int, 100) escapes to heap
./test.go:15:13: a escapes to heap // 请看这里，变量 a 逃逸到堆
./test.go:15:13: io.Writer(os.Stdout) escapes to heap
./test.go:17:13: io.Writer(os.Stdout) escapes to heap
./test.go:17:17: arr[10] escapes to heap
./test.go:15:13: main []interface {} literal does not escape
./test.go:17:13: main []interface {} literal does not escape
<autogenerated>:1: os.(*File).close .this does not escape
```
分析：`genSlice` 分配了一块内存，初始化后返回给调用者，使用后无需主动释放，由 GC 垃圾回收。严格来讲，使用者无法决定某变量在堆还是栈上分配，也可以说 GO 淡化了堆栈的概念与界线。

```
static int __netif_hw_addr_add(struct netif_hw_addr_list *list,
                               const struct ether_addr *addr)
{
    struct netif_hw_addr *ha;

    list_for_each_entry(ha, &list->addrs, list) {
        if (eth_addr_equal(&ha->addr, addr)) {
            rte_atomic32_inc(&ha->refcnt);
            return EDPVS_OK;
        }
    }

    ha = rte_zmalloc(NULL, sizeof(*ha), 0);
    if (!ha)
        return EDPVS_NOMEM;

    ether_addr_copy(addr, &ha->addr);
    rte_atomic32_set(&ha->refcnt, 1);
    ha->sync_cnt = 0;
    list_add_tail(&ha->list, &list->addrs);
    list->count++;

    return EDPVS_OK;
}
```
分析：底层开发者，上手一段 c/c++ 代码，能区分变量分配在堆或是栈上，是一种常识与基本功。但是广大的 php, python 动态语言开发者可能就没那么容易。
### defer 与 RAII
```
func (o *Once) Do(f func()) {
	if atomic.LoadUint32(&o.done) == 1 {
		return
	}

	o.m.Lock()
	defer o.m.Unlock()
	if o.done == 0 {
		defer atomic.StoreUint32(&o.done, 1)
		f()
	}
}
```
```
class DBCon{
public:
  DBCon() { 
    handle = fooOpenDBConnection();
  }
  ~DBCon() {
    int err = fooCloseDBConnection();
    if(err){
      if(err == E_fooConnectionDropped){
        // do nothing.  must have timed out
      } else if(fooIsCriticalError(err)){
        // critical errors aren't recoverable.  log, save 
        //  restart information, and die
        std::clog << "critical DB error: " << err << "\n";
        save_recovery_information();
        std::terminate();
      } else {
        // log, in case we need to gather this info in the future,
        //  but continue normally.
        std::clog << "non-critical DB error: " << err << "\n";
      }
    }
    // done!
  }
};
```
分析：RAII 在 c++ 项目中应用广泛，一般用于获取锁或是竞争资源，退出作用域时自动释放。GO 常用 defer 来实现此功能，在函数返回前，按 FILO 的顺序执行注册的 defer 函数。

### GMP 并发模型
```
func OpenDB(c driver.Connector) *DB {
	ctx, cancel := context.WithCancel(context.Background())
	db := &DB{
		connector:    c,
		openerCh:     make(chan struct{}, connectionRequestQueueSize),
		resetterCh:   make(chan *driverConn, 50),
		lastPut:      make(map[*driverConn]string),
		connRequests: make(map[uint64]chan connRequest),
		stop:         cancel,
	}

	go db.connectionOpener(ctx)
	go db.connectionResetter(ctx)

	return db
}
```
分析：上面代码来自标准库代码，打开 DB 后开启两个 goroutine 异步做其它辅助功能。开启协程如此方便，代价非常低非常轻量。写过 java  会看到，某个业务模块就得开避一个线程池 `FixedThreadPool`, 这一堆池那一堆池。对于 c/c++ 项目，一般使用 epoll, 然后多进程监听同一端口，比如 Nginx. 但是业务逻辑纯异步驱动的，熟悉 redis 的都知道，一个请求的完整流程，是分割在各处的回调函数，非常不直观。而 GO 写出来的代码，纯顺序编程，遇到阻塞式调用也不用提心。
![](images/goroutine-scheduler-model.png)
关于 [GMP](https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/) 模型网上有很多讨论，推荐看这个博客。可以简单理解为 GO 自己封装的线程池，G 代表 goroutine 执行体描述，很轻量，自带用户层的 2k 大小栈，可以拥有百万级别的 goroutine. M 代表底层线程，当前版本可以开启至多 1w 个物理线程，对于不活跃线程目前不会回收释放。P 代表逻辑并发，也就是 GOMAXCPU 个数，可动态调整，但一般都是 cpu 个数。

* go func() 只是将 func 打包成 G，提交到待运行队列中，具体何时执行，由 runtime 调度
* P 拥有本地 G 队列，优先运行本地 G，本地没有时执行全局队列，或是 steal 偷其它 P 的数据
* P 只是逻辑执行器，执行时必须绑定一个空闲的 M，PM 对可以运行多个 G，如果处于阻塞状态，那么 PM 分离，P 重新获取空闲 M 去运行新的 G
* 处于阻塞状态的 G，收到数据后被唤醒，置于 P 的待运行 G 队列中，等待调度

### CSP 交互模型
```
func (db *DB) connectionResetter(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			close(db.resetterCh)
			for dc := range db.resetterCh {
				dc.Unlock()
			}
			return
		case dc := <-db.resetterCh:
			dc.resetSession(ctx)
		}
	}
}

func (db *DB) connectionOpener(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case <-db.openerCh:
			db.openNewConnection(ctx)
		}
	}
}
```
分析：CSP（Communicating Sequential Process）一种描述并发系统交互模式的形式化语言，其交互模式是通过channel进行消息传递。GO 语言哲学，Don't communicate by sharing memory, share memory by communicating. 通过 channel 很容易实现消息传递，数据通信，超时退出等等。[channel](https://www.jianshu.com/p/39a3637804bb), goroutine, gc, memory 等等都是完整的 runtime 体系，一环扣一环。

### 接口 interface

## 语言生态圈
![](images/pop-and-hot-language.jpg)
[2019 stackoverflow 调查](https://insights.stackoverflow.com/survey/2019)显示，Python 由于 AI 机器学习的加持，持续火热。Java 系在电商及大数据领域，仍然无法撼动。Rust 新兴语言很受重注，尤其是技术范的程序员最喜欢。大家可以自己看看这份调查，很有意思。
![](images/most-salary.jpg)
薪水领域的调查，发现 clojure 居然是最高的，排在第二的就是 GO
![](images/tech-stack.jpg)
技术栈方面的图谱如上所示，左下以互联网 web 开发相关 (JavaScript, HTML/CSS, TypeScript, and React.js) 通过 DB 与微软的技术 (with C#, Visual Studio, and .NET Core) 连通，是一块大的技术栈。 一部份是移动互联网以 Java, Kotlin, Android, iOS 为主，一部份是云服务，以 Docker, AWS, K8S 做为主要生态。 当然最重要的大数据生态来自 Scala/Spark/Hadoop. 通过这里可以看过，每种语言都有自己的领域，没有最好，只有更合适
## 小白如何入门
## 老鸟如何进阶

![](images/only_money_can_persuade_me.jpg)